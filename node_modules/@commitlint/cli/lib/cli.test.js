'use strict';

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _test = require('@commitlint/test');

var _ava = require('ava');

var _ava2 = _interopRequireDefault(_ava);

var _execa = require('execa');

var _execa2 = _interopRequireDefault(_execa);

var _lodash = require('lodash.merge');

var _lodash2 = _interopRequireDefault(_lodash);

var _sander = require('sander');

var sander = _interopRequireWildcard(_sander);

var _stringToStream = require('string-to-stream');

var _stringToStream2 = _interopRequireDefault(_stringToStream);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const bin = _path2.default.join(__dirname, './cli.js');

const cli = (args, options) => (input = '') => {
	const c = (0, _execa2.default)(bin, args, {
		capture: ['stdout'],
		cwd: options.cwd,
		env: options.env
	});
	(0, _stringToStream2.default)(input).pipe(c.stdin);
	return c.catch(err => err);
};

(0, _ava2.default)('should throw when called without [input]', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_1) {
		try {
			cwd = $await_1;
			return Promise.resolve(cli([], { cwd })()).then(function ($await_2) {
				try {
					actual = $await_2;

					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should reprint input from stdin', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_3) {
		try {
			cwd = $await_3;
			return Promise.resolve(cli([], { cwd })('foo: bar')).then(function ($await_4) {
				try {
					actual = $await_4;

					t.true(actual.stdout.includes('foo: bar'));
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should produce no success output with --quiet flag', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_5) {
		try {
			cwd = $await_5;
			return Promise.resolve(cli(['--quiet'], { cwd })('foo: bar')).then(function ($await_6) {
				try {
					actual = $await_6;

					t.is(actual.stdout, '');
					t.is(actual.stderr, '');
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should produce no success output with -q flag', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_7) {
		try {
			cwd = $await_7;
			return Promise.resolve(cli(['-q'], { cwd })('foo: bar')).then(function ($await_8) {
				try {
					actual = $await_8;

					t.is(actual.stdout, '');
					t.is(actual.stderr, '');
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should succeed for input from stdin without rules', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_9) {
		try {
			cwd = $await_9;
			return Promise.resolve(cli([], { cwd })('foo: bar')).then(function ($await_10) {
				try {
					actual = $await_10;

					t.is(actual.code, 0);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should fail for input from stdin with rule from rc', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_11) {
		try {
			cwd = $await_11;
			return Promise.resolve(cli([], { cwd })('foo: bar')).then(function ($await_12) {
				try {
					actual = $await_12;

					t.true(actual.stdout.includes('type must not be one of [foo]'));
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with --config option', t => new Promise(function ($return, $error) {
	var file, cwd, actual;
	file = 'config/commitlint.config.js';
	return Promise.resolve(_test.git.bootstrap('fixtures/specify-config-file')).then(function ($await_13) {
		try {
			cwd = $await_13;
			return Promise.resolve(cli(['--config', file], { cwd })('foo: bar')).then(function ($await_14) {
				try {
					actual = $await_14;

					t.true(actual.stdout.includes('type must not be one of [foo]'));
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should fail for input from stdin with rule from js', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/extends-root')).then(function ($await_15) {
		try {
			cwd = $await_15;
			return Promise.resolve(cli(['--extends', './extended'], { cwd })('foo: bar')).then(function ($await_16) {
				try {
					actual = $await_16;

					t.true(actual.stdout.includes('type must not be one of [foo]'));
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should produce no error output with --quiet flag', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_17) {
		try {
			cwd = $await_17;
			return Promise.resolve(cli(['--quiet'], { cwd })('foo: bar')).then(function ($await_18) {
				try {
					actual = $await_18;

					t.is(actual.stdout, '');
					t.is(actual.stderr, '');
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should produce no error output with -q flag', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_19) {
		try {
			cwd = $await_19;
			return Promise.resolve(cli(['-q'], { cwd })('foo: bar')).then(function ($await_20) {
				try {
					actual = $await_20;

					t.is(actual.stdout, '');
					t.is(actual.stderr, '');
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with husky commitmsg hook and git commit', () => new Promise(function ($return, $error) {
	var cwd;
	return Promise.resolve(_test.git.bootstrap('fixtures/husky/integration')).then(function ($await_21) {
		try {
			cwd = $await_21;
			return Promise.resolve(writePkg({ scripts: { commitmsg: `'${bin}' -e` } }, { cwd })).then(function ($await_22) {
				try {
					return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_23) {
						try {
							return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_24) {
								try {
									return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"'], { cwd })).then(function ($await_25) {
										try {
											return $return();
										} catch ($boundEx) {
											return $error($boundEx);
										}
									}.bind(this), $error);
								} catch ($boundEx) {
									return $error($boundEx);
								}
							}.bind(this), $error);
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with husky commitmsg hook in sub packages', () => new Promise(function ($return, $error) {
	var upper, cwd;
	return Promise.resolve(_test.git.bootstrap('fixtures/husky')).then(function ($await_26) {
		try {
			upper = $await_26;
			cwd = _path2.default.join(upper, 'integration');
			return Promise.resolve(writePkg({ scripts: { commitmsg: `'${bin}' -e` } }, { cwd: upper })).then(function ($await_27) {
				try {
					return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_28) {
						try {
							return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_29) {
								try {
									return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"'], { cwd })).then(function ($await_30) {
										try {
											return $return();
										} catch ($boundEx) {
											return $error($boundEx);
										}
									}.bind(this), $error);
								} catch ($boundEx) {
									return $error($boundEx);
								}
							}.bind(this), $error);
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with husky via commitlint -e $GIT_PARAMS', () => new Promise(function ($return, $error) {
	var cwd;
	return Promise.resolve(_test.git.bootstrap('fixtures/husky/integration')).then(function ($await_31) {
		try {
			cwd = $await_31;
			return Promise.resolve(writePkg({ scripts: { commitmsg: `'${bin}' -e $GIT_PARAMS` } }, { cwd })).then(function ($await_32) {
				try {
					return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_33) {
						try {
							return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_34) {
								try {
									return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"'], { cwd })).then(function ($await_35) {
										try {
											return $return();
										} catch ($boundEx) {
											return $error($boundEx);
										}
									}.bind(this), $error);
								} catch ($boundEx) {
									return $error($boundEx);
								}
							}.bind(this), $error);
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with husky via commitlint -e %GIT_PARAMS%', () => new Promise(function ($return, $error) {
	var cwd;
	return Promise.resolve(_test.git.bootstrap('fixtures/husky/integration')).then(function ($await_36) {
		try {
			cwd = $await_36;
			return Promise.resolve(writePkg({ scripts: { commitmsg: `'${bin}' -e %GIT_PARAMS%` } }, { cwd })).then(function ($await_37) {
				try {
					return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_38) {
						try {
							return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_39) {
								try {
									return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"'], { cwd })).then(function ($await_40) {
										try {
											return $return();
										} catch ($boundEx) {
											return $error($boundEx);
										}
									}.bind(this), $error);
								} catch ($boundEx) {
									return $error($boundEx);
								}
							}.bind(this), $error);
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should allow reading of environment variables for edit file, succeeding if valid', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap()).then(function ($await_41) {
		try {
			cwd = $await_41;
			return Promise.resolve(sander.writeFile(cwd, 'commit-msg-file', 'foo')).then(function ($await_42) {
				try {
					return Promise.resolve(cli(['--env', 'variable'], {
						cwd,
						env: { variable: 'commit-msg-file' }
					})()).then(function ($await_43) {
						try {
							actual = $await_43;

							t.is(actual.code, 0);
							return $return();
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should allow reading of environment variables for edit file, failing if invalid', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_44) {
		try {
			cwd = $await_44;
			return Promise.resolve(sander.writeFile(cwd, 'commit-msg-file', 'foo: bar\n\nFoo bar bizz buzz.\n\nCloses #123.')).then(function ($await_45) {
				try {
					return Promise.resolve(cli(['--env', 'variable'], {
						cwd,
						env: { variable: 'commit-msg-file' }
					})()).then(function ($await_46) {
						try {
							actual = $await_46;

							t.is(actual.code, 1);
							return $return();
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should pick up parser preset and fail accordingly', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/parser-preset')).then(function ($await_47) {
		try {
			cwd = $await_47;
			return Promise.resolve(cli(['--parser-preset', './parser-preset'], { cwd })('type(scope): subject')).then(function ($await_48) {
				try {
					actual = $await_48;

					t.is(actual.code, 1);
					t.true(actual.stdout.includes('message may not be empty [subject-empty]'));
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should pick up parser preset and succeed accordingly', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/parser-preset')).then(function ($await_49) {
		try {
			cwd = $await_49;
			return Promise.resolve(cli(['--parser-preset', './parser-preset'], { cwd })('----type(scope): subject')).then(function ($await_50) {
				try {
					actual = $await_50;

					t.is(actual.code, 0);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should pick up config from outside git repo and fail accordingly', t => new Promise(function ($return, $error) {
	var outer, cwd, actual;
	return Promise.resolve(_test.fix.bootstrap('fixtures/outer-scope')).then(function ($await_51) {
		try {
			outer = $await_51;
			return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_52) {
				try {
					cwd = $await_52;
					return Promise.resolve(cli([], { cwd })('inner: bar')).then(function ($await_53) {
						try {
							actual = $await_53;

							t.is(actual.code, 1);
							return $return();
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should pick up config from outside git repo and succeed accordingly', t => new Promise(function ($return, $error) {
	var outer, cwd, actual;
	return Promise.resolve(_test.fix.bootstrap('fixtures/outer-scope')).then(function ($await_54) {
		try {
			outer = $await_54;
			return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_55) {
				try {
					cwd = $await_55;
					return Promise.resolve(cli([], { cwd })('outer: bar')).then(function ($await_56) {
						try {
							actual = $await_56;

							t.is(actual.code, 0);
							return $return();
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should pick up config from inside git repo with precedence and succeed accordingly', t => new Promise(function ($return, $error) {
	var outer, cwd, actual;
	return Promise.resolve(_test.fix.bootstrap('fixtures/inner-scope')).then(function ($await_57) {
		try {
			outer = $await_57;
			return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_58) {
				try {
					cwd = $await_58;
					return Promise.resolve(cli([], { cwd })('inner: bar')).then(function ($await_59) {
						try {
							actual = $await_59;

							t.is(actual.code, 0);
							return $return();
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should pick up config from inside git repo with precedence and fail accordingly', t => new Promise(function ($return, $error) {
	var outer, cwd, actual;
	return Promise.resolve(_test.fix.bootstrap('fixtures/inner-scope')).then(function ($await_60) {
		try {
			outer = $await_60;
			return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_61) {
				try {
					cwd = $await_61;
					return Promise.resolve(cli([], { cwd })('outer: bar')).then(function ($await_62) {
						try {
							actual = $await_62;

							t.is(actual.code, 1);
							return $return();
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should handle --amend with signoff', () => new Promise(function ($return, $error) {
	var cwd;
	return Promise.resolve(_test.git.bootstrap('fixtures/signoff')).then(function ($await_63) {
		try {
			cwd = $await_63;
			return Promise.resolve(writePkg({ scripts: { commitmsg: `'${bin}' -e` } }, { cwd })).then(function ($await_64) {
				try {
					return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_65) {
						try {
							return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_66) {
								try {
									return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"', '--signoff'], { cwd })).then(function ($await_67) {
										try {
											return Promise.resolve((0, _execa2.default)('git', ['commit', '--amend', '--no-edit'], { cwd })).then(function ($await_68) {
												try {
													return $return();
												} catch ($boundEx) {
													return $error($boundEx);
												}
											}.bind(this), $error);
										} catch ($boundEx) {
											return $error($boundEx);
										}
									}.bind(this), $error);
								} catch ($boundEx) {
									return $error($boundEx);
								}
							}.bind(this), $error);
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should handle linting with issue prefixes', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/issue-prefixes')).then(function ($await_69) {
		try {
			cwd = $await_69;
			return Promise.resolve(cli([], { cwd })('foobar REF-1')).then(function ($await_70) {
				try {
					actual = $await_70;

					t.is(actual.code, 0);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should print full commit message when input from stdin fails', t => new Promise(function ($return, $error) {
	var cwd, input, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_71) {
		try {
			cwd = $await_71;
			input = 'foo: bar\n\nFoo bar bizz buzz.\n\nCloses #123.';
			return Promise.resolve(cli([], { cwd })(input)).then(function ($await_72) {
				try {
					actual = $await_72;


					t.true(actual.stdout.includes(input));
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should not print full commit message when input succeeds', t => new Promise(function ($return, $error) {
	var cwd, message, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_73) {
		try {
			cwd = $await_73;
			message = 'foo: bar\n\nFoo bar bizz buzz.\n\nCloses #123.';
			return Promise.resolve(cli([], { cwd })(message)).then(function ($await_74) {
				try {
					actual = $await_74;


					t.false(actual.stdout.includes(message));
					t.true(actual.stdout.includes(message.split('\n')[0]));
					t.is(actual.code, 0);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should fail for invalid formatters from configuration', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/custom-formatter')).then(function ($await_75) {
		try {
			cwd = $await_75;
			return Promise.resolve(cli([], { cwd })('foo: bar')).then(function ($await_76) {
				try {
					actual = $await_76;

					t.true(actual.stderr.includes(`Using format custom-formatter, but cannot find the module`));
					t.is(actual.stdout, '');
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should fail for invalid formatters from flags', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/custom-formatter')).then(function ($await_77) {
		try {
			cwd = $await_77;
			return Promise.resolve(cli(['--format', 'through-flag'], { cwd })('foo: bar')).then(function ($await_78) {
				try {
					actual = $await_78;

					t.true(actual.stderr.includes(`Using format through-flag, but cannot find the module`));
					t.is(actual.stdout, '');
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with absolute formatter path', t => new Promise(function ($return, $error) {
	var formatterPath, cwd, actual;
	formatterPath = _path2.default.resolve(__dirname, '../fixtures/custom-formatter/formatters/custom.js');
	return Promise.resolve(_test.git.bootstrap('fixtures/custom-formatter')).then(function ($await_79) {
		try {
			cwd = $await_79;
			return Promise.resolve(cli(['--format', formatterPath], { cwd })('test: this should work')).then(function ($await_80) {
				try {
					actual = $await_80;


					t.true(actual.stdout.includes('custom-formatter-ok'));
					t.is(actual.code, 0);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with relative formatter path', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/custom-formatter')).then(function ($await_81) {
		try {
			cwd = _path2.default.resolve($await_81, './formatters');
			return Promise.resolve(cli(['--format', './custom.js'], { cwd })('test: this should work')).then(function ($await_82) {
				try {
					actual = $await_82;


					t.true(actual.stdout.includes('custom-formatter-ok'));
					t.is(actual.code, 0);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

function writePkg(payload, options) {
	return new Promise(function ($return, $error) {
		var pkgPath, pkg, result;
		pkgPath = _path2.default.join(options.cwd, 'package.json');
		return Promise.resolve(sander.readFile(pkgPath)).then(function ($await_83) {
			try {
				pkg = JSON.parse($await_83);
				result = (0, _lodash2.default)(pkg, payload);
				return Promise.resolve(sander.writeFile(pkgPath, JSON.stringify(result, null, '  '))).then(function ($await_84) {
					try {
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
}
//# sourceMappingURL=cli.test.js.map